<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.8/dist/css/bootstrap.min.css" />
  <link rel="stylesheet" href="dstyle.css" />
  <title>Document</title>
</head>

<body>
  <div class="container">
    <div class="row">
    </div>
  </div>
  <div class="container my-3"><button class="btn btn-danger" id="priceArr">가격정렬</button></div>

  <div class="container my-3"><button class="btn btn-danger" id="moreData">더보기</button></div>
  <div class="container my-3"><button class="btn btn-danger" id="moreData">가나다 역순 정렬</button></div>
  <div class="container my-3"><button class="btn btn-danger" id="moreData">6만원 이하 상품보기 필터사용</button></div>

  <script>

    // let arr = [7, 1, 5, 2, 3, 40, 50]
    // //arr.sort() //sort는 문자순으로 정렬해주세요~
    // //숫자정렬(오름차순)을 하고 싶으면
    // arr.sort((a, b) => { return a - b })
    // //내림차순은? b-a하면됨
    // //동작원리 알아봐야함
    // //a,b는 배열 안의 자료임
    // //return에는 아무 수나 들어갈 수 있는데 오른쪽이 양수면 a를 오른쪽으로 옮김
    // //오른쪽이 음수면 b를 오른쪽으로 옮김 
    // //그래서 큰 숫자일 수록 뒤로 감
    // console.log('숫자정렬임', arr)
    // //array 자료에서 내가 원하는 것만 필터하려면?
    // //필터함수를 쓰는데 콜백함수의 첫번째 파라미터는 배열에 있던 자료
    // //그리고 안에 return 문 쓰고 조건식이 필요함
    // //4보다 작은걸 arr자료에서 하나하나 빼서 검사 후 남겨줌
    // //filter 결과는 변수에 저장해서 써야함 원본을 변형시키는 sort와는 다르게 새로운걸 만든다고 생각하셈
    // // let newarr = arr.filter((a) => { return a < 4 });
    // // console.log('새배열', newarr)
    // //필터랑 비슷한 map이라는 함수는 array자료들을 전부 똑같이 변형 시킬 수 있음
    // //파라미터 의미랑 리턴문 필요한 것도 똑같음
    // //언제쓰냐? 게임에서 보면 미국돈으로 되어있는거 한화로 바꿀 수도 있잖슴? 
    // //그런거 쓸 때 게임가격이 배열로 들어가있으면 a * 환률 하면 자연스레 바뀜
    // let newarr = arr.map((a) => { return a * 4 });
    // console.log('새배열', newarr)
    // let arr2 = ['a', 'c', 'b', 'e', 'd', 'A']
    // //가나다순 정렬은?
    // //위에보면 그냥 sort만 쓰면 문자순 정렬임
    // arr2.sort();
    // console.log('가나다순', arr2)
    // //다나가 역순 정렬은? 
    // arr2.reverse();
    // console.log('가나다역순', arr2)
    // //그런데 이거 말고 sort에서도 정렬이 가능합니다.
    // arr2.sort((a, b) => {
    //   return a > b ? -1 : 1
    //   //원리를 기억하면 됨 오른쪽이 양수면 a를 오른쪽으로 옮김
    //   //음수면 b 오른쪽으로 옮김 이 원리
    // })
    // console.log('왔다갔다 할 수 있음', arr2)
    // //sort 함수는 원본을 변형시켜버립니다. 
    // //원본을 변형시켜버리면 나중에 원본으로 되돌아갈 수 없으니까 귀찮아질 수 있어서
    // //array / object 자료 조작시엔 원본을 따로 복사해두고 조작하는 경우도 있습니다. 


    var products = [
      { id: 0, price: 70000, title: 'Blossom Dress' },
      { id: 1, price: 50000, title: 'Springfield Shirt' },
      { id: 2, price: 60000, title: 'Black Monastery' }
    ];

    let cardlist = document.querySelector('.row');
    let clickcount = 0
    function 포이치(runArr) {
      runArr.forEach(item => {
        let secCardList = `<div class="col-sm-4">
        <img src="https://placehold.co/600" class="w-100">
        <h5>${item.title}</h5>
        <p>가격 : ${item.price}</p>
      </div>`
        cardlist.insertAdjacentHTML('beforeend', secCardList)
      });
    }
    포이치(products);
    //버튼누르면 products를 가격순 정렬해봅시다
    document.querySelector('#priceArr').addEventListener('click', () => {
      products.sort((a, b) => { return a.price - b.price });
      cardlist.innerHTML = ''
      포이치(products);
      clickcount = 0
      document.querySelector('#moreData').style.display = 'block'
    })

    let newarr = products.filter((a) => { return a.price <= 60000 });
    document.querySelector('#priceUnder').addEventListener ('click', ()=>{
    cardlist.innerHTML = ''
    포이치(newarr);
    })  

    //더보기 버튼 누르면 https://codingapple1.github.io/js/more1.json 여기로 get요청해서 상품받아와보셈 //완!!
    document.querySelector('#moreData').addEventListener('click', () => {
      if (clickcount == 0) {
        fetch('https://codingapple1.github.io/js/more1.json').then(response => {
          return response.json();
        }).then(data => {
          //가져온 데이터로 더보기 버튼 눌렀을 때 카드 3개 더 만들어주셈 //완!!
          포이치(data)
        })
      }
      // 1. 더보기버튼을 2번째 누르면 7, 8, 9번째 상품을 더 가져와서 html로 보여주십시오
      // https://codingapple1.github.io/js/more2.json 여기로 GET요청하면 7,8,9번째 상품이 도착합니다.
      // 힌트는 유저가 더보기버튼을 몇 번 눌렀는지를 어디 기록해놔야
      // 내가 버튼 누를 때마다 어디로 GET요청할 지 판단할 수 있겠군요. 
      // 그리고 그 다음 10, 11, 12번 상품은 없으니
      // 버튼을 3번은 못누르게 버튼을 숨기거나 그래도 좋을듯요 //구현완!
      //2. 유사한 코드가 발생하고 있습니다.
      // 지금 코드를 잘 보면 forEach() 반복문을 2번 쓴 것 같은데 
      // 이 코드들이 매우 유사해보입니다.
      // 함수나 그런걸로 축약해보는 연습도 해보면 좋을 것 같군요 //구현완!
      else if (clickcount == 1) {
        fetch('https://codingapple1.github.io/js/more2.json').then(response => {
          return response.json();
        }).then(data => {
          포이치(data)
        })
        document.querySelector('#moreData').style.display = 'none'
      }

      clickcount += 1
    })



    // //then은 말 그대로 응답이 오면~~~~(=비동기 작업이 끝나면) 아래에 작성한 내용 실행해~~이거임
    // fetch('https://codingapple1.github.io/price.json')
    //   .then(function (response) { // 1. 서버 응답(response) 받음
    //     //응답을 받는다라는 뜻은 URL로 요청을 보내면 거기에 있는 서버가 요청을 받고
    //     //서버가 준비한 데이터를 응답(response)으로 다시 내 브라우저에 보내줌
    //     //return response;  //그리고 이렇게 출력해보면 알지만 이상한 말들이 많은 그거를 text로 변환해서 내가 쓸 수 있게 바꾸려는작업
    //     // 리턴 필수임!!!!
    //     // return response.text(); // 2. 응답을 텍스트로 변환
    //     //다만 중요한 점이 있음 애초에 서버에는 JSON(문자열) 형태로 데이터가 저장되어있어서
    //     //넘어올 때 내가 어떻게 필요한지를 확인해야함 만약에 객체나 배열로 필요하면 json() 함수를 사용해서 JS객체로 변환 후 사용해야함
    //     return response.json();
    //   }).then(function (data) {     // 3. 변환된 데이터(data) 사용
    //     console.log(data.price);       // 실제 텍스트 출력
    //   });
    // fetch('https://codingapple1.github.io/hello.txt', {
    //   method: 'POST',
    //   headers: { 'Content-Type': 'application/json' }, //내가 어떤 형식의 데이터를 보낼거야 라고 알려주는 정보
    //   //'Content-Type': 'application/json' → "나는 JSON 형식으로 보낼 거야"라는 뜻
    //   body: JSON.stringify({ name: '홍길동' }) //바디는 서버로 실제로 "보내는 데이터" 예: { name: '홍길동' } 같은 객체를 보냄
    //   //하지만 서버는 문자열만 이해하므로, JSON.stringify({ name: '홍길동' })로 문자열로 바꿔서 보냄
    // }).then(function (response) { // 서버 응답(response) 받음
    //   //이곳에서 then으로 받아오는 응답은 내가 서버에 데이터를 보내더라도
    //   //그 서버에서 데이터를 잘 받았나 못받았나 에러가 났나 라는 정보들을 리턴해줌 그걸 받아오는 거임
    //   //그래서 서버에서는 항상 데이터 값을 JSON 파일로 줌
    //   return response.json();  // 응답을 JSON으로 변환
    //   //그래서 여기서 json() 훅을 사용해서 자바스크립트 객체로 변환하는 상태임
    //   //그 후에는 get처럼 아래에 데이터를 내가 꺼내서 볼 수 있게 하면 됨
    // }).then(function (data) {     // 변환된 데이터(data) 사용
    //   console.log(data);       // 실제 JSON 데이터 출력
    // }).catch(error => {
    //   console.log(error)
    // });
    // //전체적으로 보면 get이든 post든 첫번째 then에서는 정보를 .text나 .json등으로 변환만하고 실제로 데이터를 다루는 곳은 두번째 then에서 다룸
    // //이제 오류를 체크하려면 .catch() 를 쓰면 됨 .catch(error => {console.log(error)}); 이런식으로 쓰는데
    // //중요한 점은 catch는 then체인(전체 fetch요청) 마지막에 붙여서 모든 에러(네트워크,파싱 등)를 한 번에 처리하는 용도로 사용됨
  </script>
  <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.8/dist/js/bootstrap.bundle.min.js"></script>

</body>

</html>

<!-- 유저가 데이터달라고 요청을 하면 데이터를 보내주는 간단한 프로그램일 뿐입니다.

네이버웹툰 서버 : 유저가 웹툰 달라고 하면 웹툰 보내주는 프로그램

유튜브 서버 : 유저가 영상 달라고 하면 영상 보내주는 프로그램

입니다. -->
<!-- 근데 그냥 데이터달라고 떼쓰면 주는게 아니라

서버에 데이터를 요청할 때는

1. 어떤 데이터인지 url로 잘 기재해야하고

2. 어떤 방법으로 요청할지 결정해야 (GET/POST 등)
GET은 데이터 읽을 때 POST는 데이터 보낼 때

데이터를 보내줍니다. -->

<!-- GET/POST 요청하는 법?



GET요청은 서버에 있던 데이터를 읽고싶을 때 주로 사용하고

POST요청은 서버로 데이터를 보내고 싶을 때 사용합니다.

(서버는 유저데이터를 DB에 저장해주는 역할도 해서요)

실은 PUT, DELETE 요청도 있긴 합니다.





GET요청을 날리고 싶으면 가장 쉬운 방법은 브라우저 주소창입니다.

거기에 url 적으면 그 곳으로 GET요청을 날려줍니다.

진짠지 테스트해보셈



POST요청을 날리고 싶으면

<form action="요청할url" method="post"> 태그 이용하면 됩니다.

  그럼 폼이 전송되었을 때 POST요청을 날려줍니다.

  서버에서 데이터를 보내주는 역할만 하는게 아니라 가끔가다가 유저의 데이터를 받아서 DB에 저장하는 상황도있어서
  POST요청도 필요 

  근데 GET, POST 요청을 저렇게 날리면 단점이 뭐냐면 브라우저가 새로고침됩니다. -->
<!-- 
  그 새로고침이 마음에 안든다? 그럴 때 ajax를 사용한다 
  새로고침 없이 GET,POST 요청하는 기능 -->
