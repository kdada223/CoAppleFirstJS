# JS 정규식 실험/자주 틀리는 패턴 & 함수 비교

---

## (A) 자주 틀리는 대문자 범위 표현

### 🔹 비교 및 실험 코드

```js
console.log(/[A-Z]/.test('Q')); // true
console.log(/[A~Z]/.test('Q')); // false
console.log(/[A~Z]/.test('A')); // true
console.log(/[A~Z]/.test('~')); // true
console.log(/[A~Z]/.test('Z')); // true
```

### 🔹 해설

- `[A-Z]`: 올바른 대문자 알파벳 범위 지정 (A ~ Z 포함)
- `[A~Z]`: 하이픈(-)이 아니므로 범위가 아닌, "A", "~", "Z" 및 그 사이 특수문자까지 포함해 검사  
  → 실제로 "~"가 들어가면 true, "Q" 등은 false
- 실무/강의에서 범위는 반드시 `-`로 표기해야 의도한 대로 동작!

---

## (B) 여러 타입의 이메일 정규식 비교

### 🔹 실험 코드

```js
const e1 = 'test@글자.com';
console.log(/\S+@\S+\.\S+/.test(e1)); // true (허술함)
console.log(/^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$/.test(e1)); // false (엄격함)
```

### 🔹 해설

- `/\S+@\S+\.\S+/`: 공백 아닌 모든 문자로 이메일을 추출, **한글/특수문자**까지 허용해 안전하지 않음
- `/^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$/`: RFC 5322 이메일 표준 근거, 일부 특수문자만 허용 (.\_%+-), 한글/비표준문자 불허
- 실무에서는 꼭 엄격한 식을 써야 장애 예방 가능!

---

## (C) 유니코드/특수문자(한글, 기호 등) 체크

### 🔹 실험 코드

```js
/[ㄱ-ㅎ가-힣]/.test('한'); // true (한글 체크)
/[~!@#\$%\^&\*]/.test('!'); // true (특수문자 체크)
```

- 한글 범위, 특수문자 그룹 각각 문제없이 동작함

---

## (D) replace / exec / match 활용 비교

### 🔹 핵심 기능 차이

- **replace:** 정규식으로 찾은 패턴을 원하는 문자열로 **변경/치환**
  ```js
  'apple banana apple'.replace(/apple/g, 'melon'); // "melon banana melon"
  ```
- **match:** (특정 패턴) **배열로 반환**
  - `/g` 플래그 있으면 모든 매칭
  - 없으면 첫 매칭만
  ```js
  'cat dog cat pig cat'.match(/cat/g); // ["cat", "cat", "cat"]
  ```
- **exec:** (특정 패턴) **객체(배열형태) 반환, 한 번에 한 매칭씩**
  - `/g` 플래그 써도 한 번만 실행하면 첫 매칭, 반복(while문 등) 실행해야 전체 탐색
  ```js
  const regex = /cat/g;
  let m;
  while ((m = regex.exec('cat dog cat pig cat')) !== null) {
  	console.log(m[0]); // "cat" x3
  }
  ```

### 🔹 요약

- **replace:** 문자열 변경
- **match:** 배열로 “찾기”
- **exec:** 객체(배열)로 “찾기”, while로 전부 탐색

---

## 핵심 실수/교훈

- 정규식 범위, 문자 집합은 반드시 정확히 지정(하이픈/특수문자 구분)
- 실무 이메일 검증은 표준 기반 엄격 식 쓰기!
- match/exec/replace 용도/플래그(특히 `/g`)에 따라 동작 차이 존재

---

## 학습 참고/실습 아이디어

- 다양한 입력값 케이스로 직접 test, 실패/성공 비교
- replace 함수에 그룹($1, $2), 핸들러 함수 등 추가로 실험해보기
