# 2025-11-19 회고

## 오늘 한 강의 / 문제

- setTimeout, setInterval 학습 및 실험
- 정규식 기초 및 실무 적용 사례

## 핵심 개념 (Pick 3)

1. **setTimeout/setInterval은 비동기 실행**
   - JS는 싱글쓰레드라 타이머 콜백이 정확하게 실행되지 않고, 바쁠 땐 밀릴 수 있다.
2. **정규식 범위 지정 실수!**
   - `[A-Z]`는 대문자 알파벳 범위, `[A~Z]`는 범위가 아니라 `A`, `~`, `Z`등 특수문자 포함.
   - 실전에서 범위는 반드시 하이픈(-)으로 지정해야 바르게 동작한다.
3. **이메일 정규식 차이 실험**
   - 실무 정규식 `/^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$/`
   - 강의식 `/\S+@\S+\.\S+/`는 허술: 한글, 특수문자 허용됨.
   - RFC 표준에 따라 영문, 숫자, 특정 특수기호만 허용하는게 안전하다.

## 코드/실험 & 깨달은 점

### 1. **자주 틀리는 정규식 표현 테스트**

```js
console.log(/[A-Z]/.test('Q')); // true
console.log(/[A~Z]/.test('Q')); // false
console.log(/[A~Z]/.test('~')); // true
```

- `[A~Z]`는 문법적 오류가 아니라, `A`, `~`, `Z`, 그리고 ASCII 순서상 있는 문자들까지 포함.
- 강의에서 `/[A~a]/.test('a')`가 true가 나온 것도 이 원리 때문.

### 2. **이메일 정규식 비교**

```js
const e1 = 'test@글자.com';
console.log(/\S+@\S+\.\S+/.test(e1)); // true (허술함)
console.log(/^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$/.test(e1)); // false (엄격함)
```

- 실험 결과: 첫 식은 한글, 특수문자 허용. 두 번째 식은 안전한 문자만 허용.
- 실무 정규식에 포함된 특수기호(.\_%+-)는 이메일 표준(RFC 5322)에 근거.

### 3. **이벤트 루프/타이머 우선순위 실험**

```js
console.log('A');
setTimeout(() => console.log('B setTimeout'), 0);
Promise.resolve().then(() => console.log('C promise'));
queueMicrotask(() => console.log('D microtask'));
console.log('E');
// 예상 출력: A, E, C, D, B
```

- 동기 코드 → 마이크로태스크(Promise.then, queueMicrotask) → 매크로태스크(setTimeout)
- 마이크로태스크가 먼저, 매크로태스크(타임아웃, 클릭 등)는 그 다음.

### 4. **setInterval/clearInterval & 시간 정확도 실험**

```js
let count1 = 0,
	count2 = 0;
const start = Date.now();

const id1 = setInterval(() => {
	console.log('1:', ++count1, Date.now() - start, 'ms');
}, 500);
const id2 = setInterval(() => {
	console.log('2:', ++count2, Date.now() - start, 'ms');
}, 600);

setTimeout(() => {
	clearInterval(id1);
	console.log('id1 종료', Date.now() - start, 'ms');
}, 3000);
setTimeout(() => {
	clearInterval(id2);
	console.log('id2 종료', Date.now() - start, 'ms');
}, 4000);
```

- 실행 로그로 보면 이론상 6번/6~7번 반복이 나와야 하지만 실제론 누적 오차로 시간과 횟수가 달라짐.
- "1:" 6번, "2:" 6번까지만 찍힘. 타이머의 정확한 반복은 보장 X.

### 5. **setTimeout+재귀 정밀 반복 실험**

```js
function repeat(n, startTime = Date.now()) {
	if (n <= 0) return;
	console.log('count:', n, Date.now() - startTime, 'ms');
	setTimeout(() => repeat(n - 1, startTime), 1000);
}
repeat(5);
```

- 반복 때마다 1000ms씩 딱 맞게 늘어날 것 같지만 실제론 1000ms+오차 발생(1005, 2009…)
- setTimeout 재귀 방식은 콜백이 오래 걸리면 반복 간격이 넓어짐(중첩/중복 X, 오차는 있음)

#### 비교 결과 요약

- setInterval은 고정 예약이며, 바쁠 땐 반복이 겹치거나 중복될 위험이 있다.
- setTimeout+재귀는 매번 끝나고 다음 예약, 실제 간격에 더 근접(정밀함), 중복/누락 없음.

## 오늘의 깨달음

- JS의 타이머(setInterval/setTimeout)는 정확하지 않으며, 싱글스레드 바쁠 때 밀림/오차가 발생한다.
- 반복 작업이 무겁거나, 정밀 반복이 필요하면 setTimeout+재귀 방식이 더 적합하다.
- 정규식은 범위(-), 문자 집합 표기, RFC 표준까지 꼭 확인!
- 실험과 콘솔 출력으로 직접 느끼면서 교훈을 얻어가는 게 훨씬 이해가 잘된다.

## 내일 목표

- 캐러셀 만들기
- return 문법 & 소수 다루기 심화

## 짧은 자기 피드백

- 직접 실험 & 오류 코드 비교로 JS 타이머, 정규식 핵심 원리를 확실히 체득함!
- 다만 아직 CS 적인 부족함이 많이 보임
- 실전 적용·실험 주석 남기기 계속 할 것.
