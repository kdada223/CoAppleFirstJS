# 2025-11-23 회고

## 오늘 한 강의 / 문제

- for문과 반복문의 활용: 탭 메뉴를 동적 코드로 구현
- 캐러셀(이미지 슬라이더) 확장: 이미지 개수 자동 취득 → UI/로직 자동 확장
- 스크롤 이벤트 2탄: 네비바 크기 변화, 약관 스크롤 경고, progress bar

## 핵심 개념 (Pick 3)

1. **for문을 활용한 동적 이벤트 바인딩**
   - 탭(button, div 등) 수가 변경되어도 반복문으로 동적으로 이벤트 리스너를 연결하면 자동 적용
   - querySelectorAll, forEach, for문 조합으로 하드코딩을 줄이고 재사용성 확보
2. **캐러셀 구조의 확장성 설계**
   - 자식 DOM 개수(.children.length)로 슬라이드 수 자동 감지
   - 이미지 수가 변경될 때마다 width, 순회 인덱스 등 핵심값을 변수로 처리해야 견고(실패는 값, 순서, 반복식 실수 때문)
3. **스크롤 이벤트의 다양한 인터랙션**
   - window.scrollY, element.scrollTop/scrollHeight/clientHeight 등 DOM 속성 차이
   - 스크롤에 따른 네비 UI/alert/progress-bar 구현, 중복 실행 방지(상태변수)
   - 이벤트리스너/DOM요소별 scroll 속성 차이 완벽히 이해

## 코드/실험 & 깨달은 점

### 1. **for문 기반 탭메뉴 동적 처리**

```js
let Allcontents = document.querySelectorAll('.tab-content');
let AllButton = document.querySelectorAll('.tab-button');
let list = document.querySelector('.list');
for (let i = 0; i < list.children.length; i++) {
	AllButton[i].addEventListener('click', function () {
		Allcontents.forEach((item) => item.classList.remove('show'));
		AllButton.forEach((item) => item.classList.remove('orange'));
		Allcontents[i].classList.add('show');
		AllButton[i].classList.add('orange');
	});
}
```

- 탭 버튼/내용 쌍을 반복문으로 이벤트 바인딩 → 탭 수가 바뀌어도 자동 동작
- 하드코딩/직접 인덱스 지정보다 for문 반복, length 연동이 훨씬 유용

### 2. **캐러셀 구조 확장: 이미지 추가 시 자동 대응**

```js
let imgcount = 0;
let imgBox = document.querySelector('.slide-container');
let 이미지컨트롤부모 = document.querySelector('.slide-container');
let 자식수체크 = 이미지컨트롤부모.children.length;
이미지컨트롤부모.style.width = 자식수체크 * 100 + 'vw';

document.querySelector('.nextImg').addEventListener('click', function () {
	imgcount++;
	if (imgcount >= 자식수체크) imgcount = 0;
	imgBox.style.transform = `translateX(-${imgcount * 100}vw)`;
});
document.querySelector('.beforeImg').addEventListener('click', function () {
	imgcount--;
	if (imgcount < 0) imgcount = 자식수체크 - 1;
	imgBox.style.transform = `translateX(-${imgcount * 100}vw)`;
});
```

- DOM의 children.length로 이미지 개수 자동 체크, width도 자동 계산
- 하드코딩 식(자식수체크 vs 2 등 직접 인덱스)에서 실수 잦았음 → 반복·변수 활용이 정답

### 3. **스크롤 이벤트: 네비, 약관, progressBar UI 구현**

```js
// 네비브랜드 폰트 크기 변화
window.addEventListener('scroll', function () {
	let 타겟지점 = 100;
	let 매장이름 = document.querySelector('.navbar-brand');
	if (window.scrollY > 타겟지점) {
		매장이름.classList.add('smfont');
	} else {
		매장이름.classList.remove('smfont');
	}
});

// 약관박스 끝까지 스크롤 시 alert
let check = false;
document.querySelector('.lorem').addEventListener('scroll', function () {
	let 스크롤양 = this.scrollTop;
	let 실제높이 = this.scrollHeight;
	let 디브높이 = this.clientHeight;
	if (스크롤양 + 디브높이 > 실제높이 - 10) {
		if (!check) {
			alert('완료');
			check = true;
		}
	} else {
		check = false;
	}
});

// 페이지 진척도(progress bar)
window.addEventListener('scroll', function () {
	const progressBar = document.querySelector('.pageLoad');
	const scrollTop = document.querySelector('html').scrollTop;
	const clientHeight = document.querySelector('html').clientHeight;
	const scrollHeight = document.querySelector('html').scrollHeight;
	const progressItem = (scrollTop / (scrollHeight - clientHeight)) * 100;
	progressBar.style.width = progressItem + '%';
});
```

- scrollTop: 현재 스크롤 내린 양(px)
- scrollHeight: 전체 내용(스크롤 포함) 높이
- clientHeight: 현재 보이는 영역(뷰포트/클라이언트) 높이
- (스크롤 위치 + clientHeight) > 전체높이 - N : '거의 끝' 조건(성과분 기준 조절 가능)
- progress-bar는 (scrollTop / (scrollHeight - clientHeight)) \* 100 으로 0~100% 대응

## 오늘의 깨달음

- 반복문/동적 코드, 구조분리만 잘해도 복잡한 DOM 제어가 훨씬 쉬워진다!
- 캐러셀/탭/스크롤 등 모든 동적 UI는 하드코딩 대신 반복문(length, children, 배열 등)과 변수 처리 덕분에 실전 대응 완벽
- scrollTop/scrollHeight/clientHeight 등 기본 DOM속성의 의미와 차이를 완전히 이해하게 됨
- 단순히 복붙하는 게 아니라 각 개념의 목적/효과를 실험하고 코멘트로 기록하는 게 이해에 엄청 도움된다

## 내일 목표

- for문 playground 만들어서 문제 해결 2~3개 해보기
- 이벤트 버블링 강의 듣기

## 짧은 자기 피드백

- 반복문+동적대응 패턴 덕분에 DOM 조작, UI 자동화 & 유지보수 감각이 확실히 생겼다
- 스스로 코드를 짜보고, 잘못된 코드와 개선된 코드를 직접 비교해본 경험이 큰 자산이 됨
- 내일은 더 복잡한 UI/반복문/이벤트 조합에 도전해볼 것!
