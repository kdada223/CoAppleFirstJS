# 2025-11-30 회고

## 오늘 한 강의 / 문제

- localStorage를 이용한 장바구니 구현 실습
  - 상품 페이지에서 구매 버튼 클릭 시 상품명을 localStorage('cart')에 저장
  - 중복 체크(이미 있으면 alert) 구현
  - cart.html에서 localStorage에 저장된 상품명들을 불러와 렌더링
  - 응용: 객체형(cartObj)으로 {id, title, qty} 저장해 수량 증가 기능 구현
- DOM 로드 시점 처리(document.addEventListener('DOMContentLoaded')) 적용 및 안전한 초기화 패턴 습득
- JSON.stringify / JSON.parse 패턴으로 브라우저 저장소(문자열 전용) 다루기

## 핵심 개념 (Pick 3)

1. **localStorage는 문자열 저장소**
   - 값은 문자열만 저장되므로 배열/객체는 JSON.stringify로 저장하고 JSON.parse로 복원해야 함.
   - getItem 결과가 null일 수 있으므로 안전하게 || [] 또는 null 체크 필요.

2. **저장·수정 패턴: 꺼내기 → 수정 → 다시넣기**
   - 수정용 훅이 없으므로 3단계(1. load, 2. mutate, 3. save)를 항상 지켜야 데이터 일관성 유지됨.
   - 중복처리, 수량증감 등도 이 흐름에서 구현.

3. **UI와 저장소 동기화 및 에지케이스 처리**
   - 버튼 셀렉터와 데이터 배열 길이 불일치, localStorage 비어있음, 여러 탭 동기화 등 예외 케이스를 처리해야 안정적.
   - 실무에선 title 대신 고유 id 기반으로 중복 판별/식별하는 것이 안전함.

## 코드/실험 & 깨달은 점

### 1. 안전한 초기화 패턴
```js
// 로컬에 데이터가 없으면 null이 반환 -> 그냥 JSON.parse(null)은 null.
// 따라서 항상 안전하게 기본값을 지정해야 함:
let cart = JSON.parse(localStorage.getItem('cart')) || [];
```
- null 체크를 안 하면 forEach 등에서 에러 발생.

### 2. 상품명(문자열 배열) 저장 기본 구현
```js
// 버튼과 products 배열 인덱스를 맞춰서 처리하는 간단한 로직
products.forEach((product, idx) => {
  const btn = document.querySelectorAll('.buy')[idx];
  if (!btn) return;
  btn.addEventListener('click', () => {
    if (!cart.includes(product.title)) {
      cart.push(product.title);
      localStorage.setItem('cart', JSON.stringify(cart));
      alert(`${product.title} 장바구니에 추가됨`);
    } else {
      alert('이미있음');
    }
  });
});
```
- 중복 체크는 includes로 간단히 처리했으나, title 문자열의 공백/대소문자 차이로 오탐 가능.

### 3. 객체형 저장으로 수량 관리(응용)
```js
// cartObj 형태: [{id:0, title:'Dress', qty:2}, ...]
let cartObj = JSON.parse(localStorage.getItem('cartObj')) || [];
function addToCart(product) {
  let found = cartObj.find(p => p.id === product.id);
  if (found) found.qty += 1;
  else cartObj.push({ id: product.id, title: product.title, qty: 1 });
  localStorage.setItem('cartObj', JSON.stringify(cartObj));
}
```
- id 기반 비교로 안정적 중복 판별 가능. 수량/총합/삭제 구현이 수월해짐.

## 오늘의 깨달음

- localStorage는 간편하지만 "문자열 전용"이라는 제약 때문에 데이터 모델 설계(문자열 vs 객체)가 매우 중요하다.
- 항상 "꺼내기 → 수정 → 다시넣기" 흐름을 지키고, getItem 결과 null을 고려해야 에러가 없다.
- 간단한 중복 체크는 쉽게 구현되지만, 실무에서는 ID 기반 데이터 모델과 수량 관리가 표준이다.
- 여러 탭/브라우저에서 동기화가 필요하면 storage 이벤트를 추가 고려해야 한다.

## 내일 목표

- localStorage 저장 시 객체배열로 저장해 수량 생성하기
- 캐러셀 스와이프 기능 강의 듣기

## 짧은 자기 피드백

- 오늘은 기초부터 응용까지 직접 구현해보며 localStorage 사용 패턴이 체감되었다.
- 초반에 null 체크를 놓쳐 디버깅 시간이 소요됐지만, 그 경험 덕분에 안전한 초기화 패턴을 확실히 익혔다.
- 내일은 UI와 저장소를 함께 리팩토링하여 사용자 경험을 더 매끄럽게 만들겠다.
