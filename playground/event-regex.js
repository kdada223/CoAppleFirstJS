// (A) 자주 틀리는 표현 테스트

// /[A-Z]/, /[A~Z]/처럼 잘못된/잘된 코드 비교

console.log(/[A-Z]/.test('Q')); // true
// console.log(/[A~Z]/.test('Q')); // 문법 오류!
// 내가 한 실수이기에 비교


// (B) 여러 타입의 이메일 정규식 비교
/\S+@\S+\.\S+/ vs /^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$/
// 여러 이메일 input으로 두 식 test 결과 비교
// 강의 내용에서 들었던 이메일 식과 보편적으로 사용되는 이메일 식을 비교
// 이메일 알파벳, 숫자가 들어가야하는게 보편적인 email만들 때의 방식이지만
// 한글과 특수문자가 가능하게 만들어버리면 문제가 생길 수 있음 
// 그렇기에 정규식으로 영어와 숫자만 가능하게 제작
// 다만 특수하게 허용한 특수문자가 존재하는데 그 이유는
//이메일 표준(RFC 5322)에 따르면 아이디(로컬파트)는
// 아스키 문자, 숫자, 그리고 특정 특수기호를 쓸 수 있는데
// 실무에서 자주 쓰이는 건 이 6개(._%+-)사용. 이렇게를 자주 사용하기에 적용

// (D) replace/exec/match 활용 실험

// 한글/숫자/특수문자만 추출, 전화번호 포맷 변환 등
// (E) 여러 조건 결합/그룹핑/반전 실험

// /^[a-zA-Z0-9]{6,}$/ (6글자 이상 영/숫자), /^[^0-9]+$/ (숫자 없는 패턴)
// (F) 실시간 검증 vs 정적검증

// input 이벤트에서 실시간 regExp 체크 vs submit 시 체크

// 추가 실험 요소들
//   “setInterval이 1000ms로 돌아도 실제로 1초씩 정확히 동작하나?”
// “타이머 중 clearInterval 해도 콜백이 한번 더 실행될 때가 있나?”
// “/[\S]/와 /\S/ 결과가 어떻게 다를까?”
// “정규식에 +, *, ?, {}를 쓰면 input 값 따라 결과가 어떻게 바뀌지?”
// “replace에서 $1, $2 치환 그룹은 어떻게 쓰지?”
// “영문자/한글/특수문자를 동시에 체크할 수 있는 정규식은?”
