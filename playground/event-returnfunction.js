function 함수(a) {
	1 + a;
	return 123; //이런식으로 리턴을 쓰면 함수호출할 때 123을 반환함
}
함수();
//함수의 문법
//긴코드 축약가능, 파라미터 추가 기능, return 기능
//함수를 사용하고 그 자리에 뭔가 뱉고 싶으면 return
//반환해줌
//return은 아무거나 반환 가능하지만 주의점 리턴 밑에 있는 코드들은 반환이 안됨
//자동종료 기능을 가지고 있음

//함수는 자료를 넣으면 다른자료가 나오는 변환기를 만들고 싶을 때 사용함

//쇼핑몰 페이지를 만든다고 가정하면
//p태그로 가격란이 있고
//그 밑에 p태그로 부가세가 얼마인지 표시해주고 싶음 그런데 부가세가 얼마인지 계산이 필요할 때? 함수 사용하면됨
//console.log(60000 * 0.1) 부가세 예시
//이렇게 계산하면 되는데 상품이 매우 많아서 부가세를 많이 달아줘야하면?
//하드코딩하기 어려움 부가세 계산기를 만들어서 사용하면 개꿀임
function vat(a) {
	return a * 0.1;
}
//이렇게 만든 후에 vat(10000) 이런 식으로 넣으면 부가세가 자동으로 1000원이 책정되서 나옴
//그러면 console.log(60000 * 0.1) 이렇게 하드 코딩할 필요 없이
console.log(vat(60000));
//이렇게 사용해버리면 됨
//이 외에도 문자 -> 문자변환기, 숫자 -> true/false변환기 아무렇게나 제작이 가능하다.
//자바스크립트에서 소수점이 들어가있는 숫자를 연산을 할 때 약간 이상한 점이 있음
function vat2(a) {
	return a * 1.1;
}
console.log(vat2(55555)); //결과 61110.50000000001
// 이딴게 나옴
// 그 이유는 끝에 작은 오차가 발생함
// 프로그래밍 언어들은 다 이럼 자바스크립트 뿐만 아니라 소수점 연산을 할 때 약간의 오차가 발생함
//콤퓨타는 10+20을 더하라고 연산을 줘도 2진법으로 바꿔서 연산을 해버림
//그렇게 설계가 되어있음
//그래서 10 + 20 을 던져주면 1010+10100 이렇게 연산을 함
//그런데 1.1을 2진법으로 변경하면 1.0001 1001 1001 1001 1001 1001 1001 100...
//이게 반복되어버림 그래서 중간에 잘라서 반올림을 시켜버림 소수점이 들어간 놈들을 연산할때 약간의 오차가 발생가능
//1.1 + 0.3을 더해도 약간의 오차가 발생함
//1.4000000000000001 이런 답이 나옴
//매우 작은 오차가 평소에는 신경 안써도 되지만 더 정확한 연산을 하고 싶을 때는
//1. 소수점을 안쓰던가 써야하면 소수점을 전부 10 곱해서 연산하고 10으로 나누던가
//2. 편리하게 정확하게 계산해주는 라이브러리를 쓰던가
//3. 연산결과를 반올림 하던가
function vat3(a) {
	let num = (a * 1.1).toFixed(1);
	return num;
}
console.log(vat3(55555));
//toFixed는 소수점을 반올림해주세요~ 하는 함수임 숫자.toFixed(몇자리까지 반올림할지)
//이러면 끝을 반올림할 수있음.
//그런데  toFixed로 출력을 하면 정수형이 아니라 문자열 형태로 반환이 됨
//저 상태로 num + 1; 이런 코드를 짜버리면 61110.5 + 1 => 61110.51
//이렇게 붙어버림
//자바스크립트 + 연산자 특징을 보자면
// '문자' + 123 -> '문자123'
// '문자' + '문지' -> '문자문자'
//그러면 변환하는게 당연히 있을텐데
//parseFloat(값)
//parseInt(값)
//이렇게 사용하면 변환 쌉가능!
// 오늘의 숙제 :

// Q1. 함수에 분과 초를 차례로 파라미터로 입력하면 ms단위로 바꿔서 뱉어주는 함수를 만들어봅시다.

// (1초 == 1000ms 입니다)
//내가 짠 코드
function ms단위변환기(min, sec) {
	let minute = min * 60000;
	let seconds = sec * 1000;
	//초에는 1000을 곱하면 Ms가 되고 분에는 60000을 곱하면 ms가 됨
	return minute + seconds;
}
//강의하는 사람이 짠 코드
function 함수(a, b) {
	var result = (a * 60 + b) * 1000;
	return result;
} //장점 한줄로 깔끔히 관리 가능

// Q2. 가격을 파라미터로 입력하면 10% 할인된 가격을 뱉는 함수를 만들어봅시다.

// 근데 첫 구매여부도 true/false로 둘째파라미터에 입력해서 첫 구매가 맞을 경우 추가로 1.5 달러도 할인해줘야합니다.

// 주의사항은 가격으로 10.3 이런거 넣으면 소수로 인한 오차도 나올 수도 있으니 오차는 깔끔하게 처리해보든가 합시다.

// (동작예시)

// console.log(함수(70, false))
// 이렇게 사용하면 콘솔창에 63이 출력되어야합니다

// (70의 10% 할인가격이고 추가할인 없음)

// console.log(함수(10, true))
// 이렇게 사용하면 콘솔창에 7.5가 출력되어야합니다

// (10의 10% 할인가격 9에 추가할인 1.5 해줌)

function 할인가격변환기(price, first고객) {
	//10% 할인하는 방식을 만들고 소수점까지 체크가능하게 만들어놓고
	//if문으로 first고객이 true면 기존 가격에서 1.5달러를 빼주고 아니면 그냥 그대로 출력 하면 될듯함
	let sale = (price * 0.9).toFixed(1);
	let 숫자변환기 = parseFloat(sale);
	if (first고객 === true) {
		return Number((숫자변환기 - 1.5).toFixed(1));
	} else {
		return 숫자변환기;
	}
}
//first고객이 true일 경우 Number를 쓴 이유 간단히 말해서 -1.5달러를 해줌에 있어서 문제가 소수점이라 또
// 2진법 개그튼문제로 문제가 생길 수있음 그거를 방지하기 위해서 parse를 쓰는데 불편하게 늘어나니까 그냥 넘버로 작성

///////////////////////////////////////////////////////////////////////////////////////////////////////////////

// 함수, 반환, 소수점 오차 playground 실험 아이디어

// 1. return 아래 코드 실행 여부 실험
function returnTest() {
	console.log('1');
	return 2;
	console.log('이거 나오면 안됨!'); // 실행 안됨
}
console.log('returnTest 결과:', returnTest());

// 2. 소수점 오차 실험
console.log('1.1 + 0.3 =', 1.1 + 0.3); // 1.4000000000000001
console.log('55555 * 1.1 =', 55555 * 1.1); // 61110.50000000001

// 3. toFixed와 parseFloat, Number 차이 실험
let n1 = (55555 * 1.1).toFixed(1);
console.log('toFixed(1) 결과:', n1, '타입:', typeof n1); // "61110.5", string
console.log('parseFloat 적용:', parseFloat(n1) + 1); // 61111.5
console.log('Number 적용:', Number(n1) + 1); // 61111.5

// 4. 할인 함수 확장 실험 - extreme/edge test
console.log('할인가격변환기(100.7, true):', 할인가격변환기(100.7, true)); // 소수점 결과 안정성
console.log('할인가격변환기(0, true):', 할인가격변환기(0, true)); // 최저값 처음사는 고객이 0원이면 -1.5달러가되버려서 이거에 대한게 필요함
console.log('할인가격변환기(99.999, false):', 할인가격변환기(99.999, false)); // 복잡 소수점

// 5. ms단위변환기, edge 케이스
console.log('ms단위변환기(0,0):', ms단위변환기(0, 0)); // 0
console.log('ms단위변환기(1,30):', ms단위변환기(1, 30)); // 90000
console.log('ms단위변환기(100000,0):', ms단위변환기(100000, 0)); // 큰 값 테스트

// 부가: 함수식에 잘못된 값, 음수, 문자열 등 넣었을 때 결과 실험도 추가해볼 수 있음.
